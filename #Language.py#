#!/usr/bin/env python
#-*- coding: utf-8 -*-

# Usage: ./$0 ‹file utf-8 encoded›

# Vocabulary:
#  raw is the source code from $1
#  schemes are regex to find rules
#  rules are pattern-replacement relations defined within raw

import re

def recur( source, schemes, rules=[] ):
  [raw, defs] extract_rules(source, schemes, rules)

def report_applied( raw, pattern, replacement ):
  print raw
  print u"› Applied: ‘"+ pattern +u"’ ⟼  ‘"+ replacement +u"’"

def apply_rules_found( raw, rules ):
  # Unhappily: no scope consideration; no way to discover rules-consrtucted schemes
  i = 0
  for rule in rules:
    

def extract_rules( raw, schemes, rules ):
  for scheme in schemes:
    match = scheme.search(raw)
    if not match:
      if schemes[lens(schemes)-1] == scheme:
        return [raw, rules]
      continue
    (pattern, replacement) = match.groups()
    rules.append([pattern, replacement])
    # Apply once to raw's rest
    raw = raw[:match.start()] + re.sub(pattern, re_escape(replacement), raw[match.end():])
    report_applied(raw, pattern, replacement)
    return extract_rules(raw, schemes, rules)

def re_escape( string ):
  return string

def new_scheme( middle ):
  lateral = 'jilk'
  return re.compile(lateral +"\s+(.+)\s+"+re_escape(middle)+"\s+(.+)\s+"+ lateral)

schemes = []
schemes.append({new_scheme('\-\|\-'), "kind":'default'})
#schemes.append({new_scheme('==>>@'), "kind":'single-headed'})
#schemes.append({new_scheme('d=xXx=b'), "kind":'double-headed'})

import sys
raw = open(sys.argv[1]).read().decode('utf-8')
print raw
recur(raw, schemes)

